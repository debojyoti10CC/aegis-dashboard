use serde::{Deserialize, Serialize};

/// Counter applet state
#[derive(Serialize, Deserialize, Default)]
pub struct CounterState {
    pub count: i64,
    pub owner: String,
}

/// Counter applet implementation
pub struct CounterApplet {
    state: CounterState,
}

impl CounterApplet {
    /// Initialize a new counter applet
    pub fn new(owner: String) -> Self {
        Self {
            state: CounterState {
                count: 0,
                owner,
            },
        }
    }

    /// Get the current count
    pub fn get_count(&self) -> i64 {
        self.state.count
    }

    /// Increment the counter by 1
    pub fn increment(&mut self) -> i64 {
        self.state.count += 1;
        self.state.count
    }

    /// Decrement the counter by 1
    pub fn decrement(&mut self) -> i64 {
        self.state.count -= 1;
        self.state.count
    }

    /// Add a specific value to the counter
    pub fn add(&mut self, value: i64) -> i64 {
        self.state.count += value;
        self.state.count
    }

    /// Set the counter to a specific value
    pub fn set_count(&mut self, value: i64) -> i64 {
        self.state.count = value;
        self.state.count
    }

    /// Reset the counter to 0
    pub fn reset(&mut self) -> i64 {
        self.state.count = 0;
        self.state.count
    }

    /// Get the owner of the counter
    pub fn get_owner(&self) -> &str {
        &self.state.owner
    }

    /// Get the current state as JSON
    pub fn get_state(&self) -> String {
        serde_json::to_string(&self.state).unwrap_or_default()
    }
}

// Weilchain applet interface functions
// These would typically be generated by the Weilchain SDK

#[no_mangle]
pub extern "C" fn init(owner: *const u8, owner_len: usize) -> *mut CounterApplet {
    let owner_slice = unsafe { std::slice::from_raw_parts(owner, owner_len) };
    let owner_str = String::from_utf8_lossy(owner_slice).to_string();
    
    let applet = CounterApplet::new(owner_str);
    Box::into_raw(Box::new(applet))
}

#[no_mangle]
pub extern "C" fn get_count(applet: *mut CounterApplet) -> i64 {
    let applet = unsafe { &*applet };
    applet.get_count()
}

#[no_mangle]
pub extern "C" fn increment(applet: *mut CounterApplet) -> i64 {
    let applet = unsafe { &mut *applet };
    applet.increment()
}

#[no_mangle]
pub extern "C" fn decrement(applet: *mut CounterApplet) -> i64 {
    let applet = unsafe { &mut *applet };
    applet.decrement()
}

#[no_mangle]
pub extern "C" fn add(applet: *mut CounterApplet, value: i64) -> i64 {
    let applet = unsafe { &mut *applet };
    applet.add(value)
}

#[no_mangle]
pub extern "C" fn set_count(applet: *mut CounterApplet, value: i64) -> i64 {
    let applet = unsafe { &mut *applet };
    applet.set_count(value)
}

#[no_mangle]
pub extern "C" fn reset(applet: *mut CounterApplet) -> i64 {
    let applet = unsafe { &mut *applet };
    applet.reset()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_counter_basic_operations() {
        let mut counter = CounterApplet::new("test_owner".to_string());
        
        assert_eq!(counter.get_count(), 0);
        assert_eq!(counter.increment(), 1);
        assert_eq!(counter.increment(), 2);
        assert_eq!(counter.decrement(), 1);
        assert_eq!(counter.add(5), 6);
        assert_eq!(counter.set_count(10), 10);
        assert_eq!(counter.reset(), 0);
    }

    #[test]
    fn test_counter_owner() {
        let counter = CounterApplet::new("alice".to_string());
        assert_eq!(counter.get_owner(), "alice");
    }
}